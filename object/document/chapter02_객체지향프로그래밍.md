## 객체지향프로그래밍

### 협력, 객체, 클래스

* 객체지향 패러다임으로의 전환은 클래스가 아닌 **객체에 초점을 맞출 때**에만 얻을 수 있다.
* 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민해야한다.
  * 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것
  * 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야한다.
* 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.
  * 객체를 고립된 존재로 바라보지 말고 협력에 참여하는 협력자로 바라봐야한다.
  * 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현해야 한다.

### 객체? 클래스?

* 객체와 클래스는 어떻게 다를까?
  * "Customer라는 클래스를 만들었다고 실제 고객이 생기는 걸까?"
  * 클래스(Customer)는 그냥 설계도일 뿐이다. 
  * 실제 고객이 존재하려면 객체를 생성해야 한다.
  * 즉, 클래스를 만들었다고 끝이 아니라, 반드시 객체를 만들어야 프로그램이 실행된다.

개념|설명|예제
---|---|---
클래스 (Class)|객체를 만들기 위한 설계도|```class Customer(val name: String)```
객체 (Object)|클래스의 설계도로 만들어진 실제 실체|```val alice = Customer("Alice")```

* "클래스를 먼저 설계하면 안 된다"는 게 무슨 의미일까?
  * "결국 고객, 계좌, 은행 같은 클래스를 만들 거면, 그냥 클래스 중심으로 생각하면 되는 거 아닌가?"
  * 여기서 핵심은 다음과 같다. **"클래스를 먼저 설계하지 말고, 객체가 어떻게 협력할지 먼저 고민해야 한다."** 
  * 즉, "은행 시스템에는 어떤 클래스가 필요할까?"라고 생각하는 게 아니라, **"은행 시스템에서 어떤 객체들이 존재하고, 어떻게 서로 협력할까?"** 를 먼저 고민해야 한다.


* 📌 클래스를 먼저 고민하면 발생하는 문제점 
  * ❌ "음... 은행이니까 BankAccount, Customer, Bank 클래스를 만들어야겠군!"
  * ❌ "이제 각 클래스 안에 어떤 필드와 메서드를 넣을지 고민해볼까?"
  * ❌ "음... 그런데 어떻게 서로 연결하지?"


* 이렇게 되면 객체들의 협력 관계를 나중에 억지로 맞추게 된다.
  * 즉, 객체 간의 자연스러운 협력보다는 '데이터 중심'으로 클래스만 나열하게 된다.
  * 결과적으로, 객체지향이 아니라 절차지향 방식처럼 동작할 가능성이 높아진다.


* 객체지향 프로그래밍의 가장 좋은 방법은 다음과 같다. **"객체들의 역할과 상호작용을 먼저 생각하는 것"**


* 🎭 역할을 먼저 고민하면 다음과 같다.
  * 은행 시스템에는 고객이 있다.
  * 고객은 은행에서 계좌를 개설할 수 있다.
  * 계좌는 입금, 출금 기능을 가지고 있다.
  * 은행은 여러 계좌를 관리한다.


* 위처럼 설계하면 객체들의 역할이 보이고, 이 역할과 상호작용을 코드로 표현하면 비로소 **클래스**가 된다.

### 클래스 구현하기

* 클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 **클래스의 경계를 구분 짓는 것** 이다.
* 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.
* 클래스의 내부와 외부를 구분해야하는 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다.
* 또 다른 이유로는 프로그래머에게 구현의 자유를 제공하기 때문이다.

### 자율적인 객체 (경계의 명확성이 객체의 자율성을 보장)

* 객체는 **상태와 행동을 함께 가지는 복합적인 존재**다.
* 객체는 **스스로 판단하고 행동하는 자율적인 존재**다.


* 캡슐화(Encapsulation)란? 
  * 📌 정의
    * 객체의 데이터(필드, 상태)와 행동(메서드, 기능)을 하나로 묶는 것
    * 데이터를 외부에서 직접 접근하지 못하도록 보호하는 것
  * 📌 비유하자면?
    * ✔ 자동차를 생각해 보자!
    * ✔ 자동차 내부에는 엔진, 변속기, 브레이크 시스템 같은 중요한 부품이 있어.
    * ✔ 하지만 운전자가 엔진을 직접 만지는 게 아니라, 가속 페달과 브레이크(인터페이스)를 통해 조작하지!
    * 👉 자동차 내부 부품은 캡슐화되어 있고, 운전자는 외부에서 조작 가능한 기능만 사용할 수 있는 것과 같아!


* 캡슐화를 통해 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.
* 즉, **"경계를 명확히 해야 객체의 자율성을 보장할 수 있다."**
  * 💡 여기서 "객체의 자율성"이란?
    * 👉 객체가 자기 자신을 스스로 관리하고, 외부에서 멋대로 조작하지 못하게 하는 것!
  * 만약 내부 데이터를 외부에서 마음대로 변경할 수 있다면?
    * 👉 객체가 스스로의 상태를 안전하게 유지할 수 없게 돼.


* 일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야 한다.
* 따라서, 클래스의 속성은 private 으로 선언해서 감추고, 외부에 제공해야하는 일부 메서드만 public 으로 선언하면 좋다.

### 프로그래머의 자유 (프로그래머에게 구현의 자유를 제공)

* 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨긴다. 
  * 구현 은닉 : 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고, 마음대로 변경할 수 있다.
* 클라이언트 프로그래머는 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축한다.

### 컴파일 시점의 의존성과 실행 시점의 의존성이 다를 가능성이 크다

* 컴파일 시점의 의존성: 소스 코드에서 명시적으로 참조하는 클래스나 인터페이스와의 관계
* 실행 시점의 의존성: 실제 프로그램 실행 중에 객체가 할당되고 사용하는 구체적인 클래스


* 유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다를 확률이 높다.

```kotlin
// 인터페이스
interface Payment {
    fun pay()
}

// 구현 클래스 1
class CreditCardPayment : Payment {
    override fun pay() {
        println("Paying with Credit Card.")
    }
}

// 구현 클래스 2
class PayPalPayment : Payment {
    override fun pay() {
        println("Paying with PayPal.")
    }
}

// 컴파일 시점: PaymentProcessor 는 Payment 인터페이스에 의존
class PaymentProcessor(
  val payment: Payment,
) {
    fun process() {
        payment.pay()
    }
}

// 실행 시점: 실제 사용할 객체가 결정됨
fun main() {
    val payment: Payment = PayPalPayment() // 실행 시점에 PayPalPayment 선택
    val processor = PaymentProcessor(payment)
    processor.process()
}
```

### 차이에 의한 프로그래밍

* 상속은 **객체지향에서 코드를 재사용**하기 위해 가장 널리 사용되는 방법이다.
* 상속을 이용하면 **클래스 사이에 관계를 설정**하는 것만으로 **기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함**시킬 수 있다.
* 차이에 의한 프로그래밍이란 **부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법**이다.


* 📌 코드를 재사용하기 위해서 꼭 상속을 사용해야할까? -> ❌
  * 상속은 중복을 제거하기에 아주 좋은 객체지향 기술처럼 보이고, 그에 따라 상속을 무분별하게 남발하는 경우를 자주 볼 수 있다. 
  * 하지만 상속을 이용해야 하는 경우는 상당히 선택적이며, 상속이 갖는 단점은 상당히 치명적이기 때문에 상속보다는 **Composition** 을 이용할 것을 권장하는 경우가 많다.
  * (1) 강한 결합(Tight Coupling) 문제 
    * 상속을 사용하면 부모 클래스가 변경될 때, 모든 자식 클래스가 영향을 받을 수 있다. 
    * 부모 클래스의 변경이 어려워지므로 유지보수성이 떨어질 수 있다.
  * (2) 다중 상속 문제 
    * Java 는 다중 상속을 지원하지 않으므로(단, 인터페이스 다중 구현은 가능) 한 클래스가 여러 부모 클래스를 상속받을 수 없다. 
    * 다중 상속이 가능한 언어(C++, Python 등)에서도 다이아몬드 문제(상속 충돌)가 발생할 수 있다.
  * (3) 유연성이 부족 
    * 상속을 사용하면 컴파일 시점에 부모 클래스가 고정되므로 실행 시점에 다른 기능으로 교체하기 어려움 
    * 대신 인터페이스나 **Composition** 을 활용하면 더 유연한 설계가 가능
  * (4) 캡슐화를 위반
    * 상속을 이용하기 위해서는 부모 클래스와 내부 구조를 잘 알고 있어야 한다. (결합도가 높아진다.)


* 상속의 진정한 목적은 코드 재사용이 아니라, **다형성을 활용하기 위한 서브타입 계층을 구축**하는 것이다. 
* 타입 계층에 대한 고민 없이 코드를 재사용하기 위해 상속을 사용하면 이해하기 어렵고, 유지보수하기 버거운 코드가 만들어질 뿐이다.


* 따라서 구현 상속(class 상속)보다는 인터페이스 상속을 사용하는 것이 더 좋다.

### 상속과 인터페이스

* 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.
* 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.
* 결과적으로 **자식 클래스**는 부모 클래스가 수신할 수 있는 **모든 메시지를 수신**할 수 있기 때문에 **외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주**할 수 있다.

### 다형성

* 동일한 코드(부모 클래스)를 사용하더라도, 실행 시점에서 다양한 동작(자식 클래스의 구현)이 가능한 것이 다형성의 핵심
* 즉, 컴파일 시점에 동일한 코드를 호출하지만, 실제로 어떤 메서드가 실행될지는 객체의 클래스가 무엇이냐에 따라 달라진다.